# Chapter 2 회고록

---

항해를 떠난지 벌써 5주차가 되었습니다. <br/>
이전과 확실히 다른 모습으로 하루하루를 보내고 있습니다.

## 🐱‍🏍 Chapter 2
### 시나리오 요구사항 별 분석 및 자료 제출
항해를 시작하기 전부터 관심을 가지고 있었던 콘서트를 선택했습니다. <br/>
다수의 사용자가 동시에 이벤트를 발생시킬 경우, 어떻게 처리할지에 대해 무척이나 궁금했습니다. <br/>
시나리오 선택 후 요구사항을 면밀히 분석하였고, Milestone, 시퀀스 다이어그램, ERD, API 명세서, Mock API를 작성했습니다. <br/>
이를 통해 시스템의 전반적인 구조와 흐름을 이해하게 되었습니다.

### 각 시나리오별 하기 비즈니스 로직 개발 및 단위 테스트 작성 
4주차는 많은 공수가 들어갔던 시기였습니다.<br/> 
모든 비즈니스 로직이 정상적으로 동작하도록 구현해야 했고, 그에 따른 단위 테스트와 통합 테스트도 진행했습니다.<br/>
초반에 시간 조율을 잘못하여 아키텍처 설계에 고민을 하다가 후반에 힘들게 작업했던 기억이 있습니다.<br/>
이 과정을 통해 설계의 중요성을 다시 한번 절실히 깨닫게 되었습니다.<br/>

### 에러 코드 정의 및 관리 체계 구축
5주차는 새로운 개념과 알고 있었지만 세부적으로 몰랐던 것들을 배우는 기회가 되었습니다.<br/>
글로벌 에러 핸들러를 통해 예외 로깅 및 응답 처리 핸들러를 구현하는 것은 처음 해보는 경험이었고, 흥미를 느끼며 작업했습니다.<br/>

### 동시성 제어
좌석 예약에서는 낙관적 락을 사용하였고, 포인트 충전에는 비관적 락을 적용했습니다.<br/>
좌석 예약의 경우 다수의 사용자가 접근할 수 있어 동시성 제어가 필수적이었습니다. <br/>
낙관적 락과 비관적 락을 고민하던 중, 비관적 락에 비해 리소스 소비가 낮은 낙관적 락을 선택하게 되었습니다.<br/>
클라이언트에게 실패를 알리지 않으므로, 시스템의 가용성에도 긍정적인 영향을 미칠 것이라고 판단했습니다. <br/>
반면, 포인트 충전에는 비관적 락을 사용한 이유는 단일 유저가 포인트 충전을 진행하기 때문에<br/>
성능을 포기하고 정합성을 우선시했습니다.

## ✨느낀점
### 이상적인 아키텍처 설계는 계속된다...
아키텍처 설계는 한 번에 끝나는 것이 아니라 지속적으로 발전해 나가야 한다는 점을 깨달았습니다.<br/>
각 단계에서의 피드백을 반영하여 최적의 설계를 도출하는 것이 중요합니다.

### Filter와 Interceptor의 차이
Filter와 Interceptor의 사용 목적과 동작 방식을 명확히 이해하는 것이 필요했습니다.<br/>
각 개념의 차이를 이해함으로써, 적절한 상황에서 적합한 기술을 선택할 수 있는 능력을 키웠습니다.

### 유즈케이스에 따른 동시성 제어
각 유즈케이스에 맞는 동시성 제어 전략을 채택하는 것이 시스템의 안정성과 성능을 보장하는 데 중요한 요소라는 점을 깨달았습니다. <br/>
